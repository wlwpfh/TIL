애플리케이션 여러 개를 배포하려고 할 때, 커뮤니케이션을 할 수 밖에 없다.

→ 이 커뮤니케이션의 두 패턴

1. 동기 커뮤니케이션 (애플리케이션 → 애플리케이션)
2. 비동기/ 이벤트 기반 유형 (애플리케이션 → 큐 → 애플리케이션, 직접 소통하지 않는다.)

애플리케이션 간의 동기화는 때로 문제가 될 수 있다.

→ 트래픽이 갑자기 많아지는 때, 아무것도 예측할 수 없을 때

⇒ 이럴 때 애플리케이션을 분리(decouple)하고 분리 계층을 확장하는 것이 좋다.

- SQS: queue model
- SNS: pub/sub model
- Kinesis: 실시간 스트리밍

---

## SQS

대기열

SQS 대기열에는 메시지를 포함한다.

생산자 = SQS 대기열에 메시지를 보내는 주체 send message

소비자 = SQS 대기열에서 나온 메시지를 처리하고 수신해야 하는 대상 poll message

→ 대기열에게 소비자 앞으로 온 메시지가 있는지 물어보기

대기열은 생상자와 소비자의 버퍼 역할을 한다.

### Amazon SQS - Standard Queue

- aws에서 제공하는 가장 오래된 서비스
- 완전 관리형 서비스, 애플리케이션을 분리하는데 사용된다.
- 속성
    1. 무제한 처리량을 얻을 수 있다. 대기열에 있는 메시지 수에 제한이 없다.
    2. 메시지는 기본으로 4일동안 대기열에 남아 있고 최대 14일동안 있을 수 있다.
    3. 지연시간이 짧다. → 보내거나 읽을 때 매우 빠르게 응답을 받을 수 있다.
    4. 메시지는 작아야한다. (256kb 미만)
- 중복 메시지가 있을 수 있다.
- 초서느이 오더라는 뜻으로 품절 메시지를 보낼 수 있다.

### SQS - Producing Messages

메시지가 생산자에 의해 SQS로 보내진다.

→ 그 과정: SDK 소프트웨어 개발 키트를 사용하여 SQS에 메시지를 보낸다.

SendMessage: SQS에 메시지를 보내는 API

메시지가 작성되면 소비자가 메시지를 읽고 삭제할 때까지 SQS 대기열에 유지된다.

메시지가 삭제되었다 ⇒ 메시지가 처리되었다.

### SQS - Consuming Messages

소비자는 일부 코드로 작성해야 하는 애플리케이션이다.

⇒ ec2 instance, aws lambda, …

대기열에는 소자가 있고 소비자는 SQS 메시지를 폴링한다.

(한번에 최대 10개의 메시지를 받는다)

소비자는 받아서 rds에 넣을 수 있다.

DeleteMessage API로 메시지를 삭제할 수 있다.

### SQS - Multi EC2 instances consumer 여러 소비자를 동시에 가지기

SQS 대기열은 메시지를 동시에 수신하고 처리할 소비자를 여러 개 가질 수 있다.

각 소비자는 poll 함수를 호출하여 다른 메시지 세트를 수신하게 된다.

소비자가 메시지를 처리하면 메시지를 삭제해야 한다.

### SQS with Auto Scaling Group

소비자를 수평 확장하여 처리량을 개선할 수 있다.

소비자가 ASG의 내부에서 인스턴스를 실행하고 SQS 대기열에서 메시지를 폴링할 것이다.

ASG는 지표에 따라 확장되어야 하는데 이 지표는 대기열의 길이이다.

(= ApproximateNumberOfMessage - CloudWatch Metric임)

### SQS to decouple between applications tiers

파일 요청과 파일 처리가 다른 애플리케이션에서 발생하도록 할 수 있다.

요청이 오면 SQS 대기열로 메시지를 전송하는 것이다.

파일 처리는 메시지를 수신해서 처리한다.

### Amazon SQS - Security

- 암호화

→ HTTPS API를 이용해서 비행 중 암호화를 한다.

→ KMS 키를 사용하여 미사용 암호화를 얻는다.

→ 원한다면 클라이언트 측 암호화를 할 수 있다.

- 액세스 제어

→ IAM 정책은 SQS API에 대한 액세스를 규제할 수 있다.

- S3 버킷 정책과 유사한 SQS 액세스 정책이 있다.

### SQS - Message Visibility Timeout  메시지 가시성 시간 초과

소비자가 메시지를 폴링하면 그 메시지는 다른 소비자들에게 보이지 않게 된다. (ReceiveMessage Request)

message visibility timeout은 기본적으로 30초이다.

→ 30초 이내에 메시지가 처리되어야 한다.

이 기간 내에서는

이 기간이 지나고 메시지가 삭제되지 않았으면 메시지는 대기열에 다시 넣어진다.

→ 그러면 다른 소비자가 ReceiveMessage Request를 하면 이전의 그 메시지를 또 받게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0e50c9f9-d6b9-4369-b0d8-a40d14ac1451/c7848503-5c31-4ec6-8a96-a74ff87692ff/Untitled.png)

→ 가시성 시간 초과 기간 내에 메시지를 처리하지 않으면 메시지가 두번 처리될 수 있다.

ChangeMessageVisibility API라는 걸 사용할 수 있다.

→ 효과: 소비자가 메시지를 처리하는데 시간이 더 필요하고 해당 메시지를 두 번 처리하고 싶지 않을 때

시간을 결정할 대에는 너무 길게/ 짤벡는 하면 안된다.

→ 애플리케이션에 합당하도록 설정해야 한다.

### Amazon SQS - Long Polling

소비자가 대기열에 메시지를 요청하는데 대기열에 아무것도 없다면 메시지 도착을 기다리면 된다.

⇒ long polling

이걸 하는 이유

1. 지연 시간 줄이기
2. SQS로 보내는 API 호출 숫자를 줄이기 위해서

롱폴링 중간에 메시지가 도착하면 자동으로 메시지가 소비자에게 전송된다.

롱폴링은 SQS로의 API 호출 숫자를 줄인다.

→ 효율성과 대기 시간을 증가시킨다.

구성 방법

1. 대기열 레벨에서 구성
2. WaitTimeSecond를 사용하는 API 레벨

### SQS - FIFO Queue

= 대기열에 첫번째로 도착한 메시지가 대기열을 떠날 때도 첫번째가 되도록 대기열 내의 순서가 정렬된다.

(표준 대기열보다 순서가 더 확실히 보장된다.)

순서가 정해져 있기에 처리량에 제한이 있다.

→ 묶음이 아니라면 초당 300개의 메시지를 처리하고 묶음으로 보내면 3000개를 처리한다.

중복을 제거해주는 기능을 통해 정확히 한 번만 보낼 수 있다.

메시지가 소비자에 의해 순서대로 처리된다.

### SQS with Auto Scaling Group

SQS와 ASG가 있을 때, ASG 내의 인스턴스에 메시지를 SQS 대기열에서 폴링한다.

→ 오토 스케일링 그룹을 자동으로 대기열의 크기에 따라 확장시키기 위해 cloudwatch metric을 이용한다.

**이걸 활용하는 패턴**

1. if the load is too big, some transcations may be lost

   → SQS를 데이터베이스 쓰기에 버퍼 역할로 사용한다.

   바로 요청을 쓰는 대신, 애클리케이션이 SQS  대기열에 먼저 쓰는 방식이 있다.

   → 유실되는 데이터가 없다.

2. decouple between application tiers

   애플리케이션이 요청을 전달받고 응답을 재전송하는 대신 이 과정을 분리해서 모든 요청을 SQS 대기열로 전달해서 그 다음 애플리케이션으로 전송한다.