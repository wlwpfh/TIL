## 13장 검색어 자동완성 시스템  

### 1장 문제 이해 및 설계 범위 확정  

1. 단어의 자동완성이 되는 부분은 첫 부분
2. 5개의 자동 완성 검색어 표시
3. 질의 빈도에 따라 정해지는 검색어 인기 순위 기준
4. 다국어 지원
5. 일간 능동 사용자 기준으로 천만명 

+ 요구사항 
1. 빠른 응답 속도 - 시스템의 응답속도는 100밀리초 이내
2. 연관성 - 사용자가 입력한 단어와 연관된 단어가 나오도록
3. 정렬 - 인기도 등의 순위 모델에 의해 정렬되어 있어야 함
4. 규모 확장성 - 많은 트래픽을 감당할 수 있도록 확장 가능해야 함  
5. 고가용성 - 서비스에 장애가 발생하더라도 시스템은 계속 사용 가능해야 함

**- 개략적 규모 추정**   
일간 사용자는 천만 명으로 가정하며 평균적으로 한 사용자는 매일 10건의 검색을 수행한다.  
질의할 때마다 평균적으로 20 바이트의 데이터를 입력한다.  
질의문은 평균적으로 4개의 단어로 이뤄진다. 한 단어는 5글자로 구성된다.  (4*5=20)  
검색창에 글자를 입력할 때마다 클라이언트는 검색어 자동완성 백엔드에 요청을 보낸다.   

초당 24000건의 질의가 발생할 것이다. 
최대 QPS는 대략 48000건이다.  
질의 가운데 20%는 신규 검색어이다.  
매일 0.4GB의 신규 데이터가 시스템에 추가된다.  

<hr/>

### 2단계 개략적 설계안 제시 및 동의 구하기   

시스템을 두 부분으로 나눌 수 있다.
1. 데이터 수집 서비스: 사용자가 입력한 질의를 실시간으로 수집하는 시스템이다. 
2. 질의 서비스: 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓은 서비스이다.  

**데이터 수집 서비스**  
질의문과 사용빈도를 저장하는 빈도 테이블이 있다.  

**질의 서비스**  
query: 질의문을 저장하는 필드이다.  
frequency: 질의문이 사용된 빈도를 저장하는 필드다.  

이는 데이터의 양이 적을 때에는 나쁘지 않지만 데이터가 많아지면 데이터베이스가 병목될 수 있다.  


### 3단계 상세 설계 

**1. 트라이 자료구조**  
관계형 데이터베이스에서 가장 인기 있었던 다섯 개 질의문을 골라내는 방안은 효율적이지 않다.  
그렇기에 이 문제는 **트라이**를 이용하여 해결할 것이다.  

트라이는 문자열들을 간략하게 저장할 수 있는 자료구조이다. 이는 문자열을 꺼내는 연산에 초점을 맞추어 설걔된 자료구조이다.  

- 트라이는 트리 형태의 자료구조이다.  
- 이 트리의 루트 노드는 빈 문자열을 나타낸다.  
- 각 노드는 글자하나를 저장하며 26개의 자식 노드를 가질 수 있다.  
- 각 트리 노드는 하나의 단어, 또는 접두어 문자열을 나타낸다.  

트라이 노드에 문자들을 저장하고 이용 빈도를 저장한다.  

- 트라이로 자동완성을 구현하는 방법  
: 해당 접두어를 표현하는 노드를 찾는다 (`O(p)`)  
: 해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다.  
: 이를 정렬하여 가장 인기 있는 검색어 k개를 찾는다.   
->  이 알고리즘의 시간 복잡도는 `O(p) + O(c) + O(clogc)`이다.    

- 단점
: 직관적이지만 k개를 얻기 위해 전체 트라이를 다 검색해야 하는 일이 생길 수 있다.  

- 보완점
: 접두어의 최대 길이를 제한 - 50과 같은 작은 정수값으로 가정해도 안전하다.
: 각 노드에 인기 검색어를 캐시 


- 보완 후 시간 복잡도
: 접두어 노드를 찾는 시간 `O(1)`
: 최고 인기 검색어 k개를 찾는 알고리즘 복잡도 - `O(1)`


<br/>

**2. 데이터 수집 서비스**  

하지만 실시간마다 데이터를 수정하면 서비스는 심각하게 느려진다.  
트라이가 만들어지고 나면 인기 검색어는 그다지 자주 바뀌지 않을 것이다. 그러니 자주 갱신할 필요는 없다.  

데이터 수집 서비스의 토대는 바뀌지 않을 것이다. 트라이를 만드는 데 쓰는 데이터는 보통 데이터 분석 서비스나 로깅 서비스로부터 올 것이다.  

과정은 `데이터 분석 서비스 로그 > 로그 취합 서버 > 취합된 데이터 > 작업 서버 > 트라이 데이터베이스 > 트라이 캐시`이다.  

- 데이터 분석 서비스 로그  
: 검색창에 입력된 질의에 대한 원본 데이터가 보관된다.  
: 추가는 있지만 수정은 없으며 로그 데이터에는 인덱스를 걸지 않는다.  

- 로그 취합 서버   
: 결과를 빨리 보여주는 것이 중요한 경우에는 데이터 취합 주기를 짧게 가져가는 것이 좋다.  
: 일정 기간의 주기를 통해 취합하면 충분할 것이다.  

- 취합된 데이터
: 매주 취합된 데이터의 사례이다.  
: query - time - frequency 데이터를 가진다.  
: frequency는 해당 질의가 해당 주에 사용된 횟수의 합이다.  

- 작업 서버  
: 주기적으로 비동기적 작업을 실행하는 서버 집합이다.  
: 트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할을 담당한다.  

- 트라이 캐시  
: 분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높이는 구실을 한다.  
: 매주 트라이 데이터베이스의 스냅샷을 떠서 갱신한다.  

- 트라이 데이터베이스  
: 지속성 저장소이다.  
: 문서 저장소 - 새 트라이를 매주 만들 것이기에 주기적으로 트라이를 직렬화하여 데이터베이스에 저장할 수 있다.  
: 키-값 저장소 - 트라이에 로직을 적용하면 해시 테이블 형태로 변환 가능하다.  
    - 트라이에 보관된 모든 접두어를 해시 테이블 키로 변환   
    - 각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환  

<br/>

**3. 질의 서비스**  
1. 검색 질의가 로드밸런서로 전송된다.  
2. 로드밸런서는 해당 질의를 API 서버로 보낸다.  
3. 서버는 트라이 캐시에서 데이터를 가져와 해당 요청에 대한 자동완성 검색어 제안 응답을 구성한다.  
4. 데이터가 트라이 캐시에 없는 경우에는 데이터를 데이터베이스에서 가져와 캐시에 채운다. 

- 번개처럼 빠른 질의를 위한 최적화 방안 
1. ajax 요청: ajax 요청을 보내 자동완성된 검색어 목록을 가져온다.  
2. 브라우저 캐싱: 검색어들을 브라우저 캐시에 넣어두면 후속 질의 결과는 해당 캐시에서 바로 가져갈 수 있다.  
3. 데이터 샘플링: n개의 요청 가운데 1개만 로깅하도록 하는 것이다.  

**4. 트라이 연산**  
1. 트라이 생성
- 트라이 생성은 작업 서버가 담당하며, 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 이용한다.  

2. 트라이 갱신   
- 갱신하는 방법은 두 방법이 있다.    
    - 매주 한번 갱신하는 방법: 새로운 트라이를 만든 다음에 기존 트라이를 대체한다.  
    - 트라이의 각 노드를 개별적으로 갱신하는 방법: 트라이 노드를 갱신할 때는 모든 상위 노드도 갱신해야 하는데, 상위 노드에도 인기 검색어 질의 결과가 보관되기 때문이다.   

3. 검색어 삭제  
- 위험한 질의어를 자동완성 결과에서 제거해야 한다. 
- 방법으로는 트라이 캐시 앞에 필터 계층을 두어 부적절한 질의어가 반환되지 않도록 하는 것이다.  

<br/>

**5. 저장소 규모 확장**  

검색어는 영어만 지원하면 되기에 첫 글자를 기준으로 샤딩하는 방법을 생각할 수 있다.  
이 방법을 사용하는 경우 최대 26대의 서버가 있을 수 있다.  

이 방법은 그럴듯 보이지만 데이터가 생각보다 많으며 이를 각 서버에 균등하게 배분하는 것은 불가능하다.  

이 문제를 해결하기 위해 과거 질의 데이터의 패턴을 분석하여 샤당하는 방법을 추천한다.  


<hr/>


### 4단계 마무리 
추가로 생각할 수 있는 부분   
* 다국어 지원 - 트라이에 유니코드를 사용하여 저장한다.  
* 국가별로 인기 검색어 지원 - 국가별로 다른 트라이를 사용 -> `CDN`에 저장하여 응답 속도를 빠르게 할 수 있음  
