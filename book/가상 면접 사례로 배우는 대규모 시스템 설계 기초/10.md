## 10장 알림 시스템 설계  

알림 시스템은 모바일 푸시 알림, SMS 메시지, 이메일로 세 가지로 분류할 수 있다.  

### 1단계 문제 이해 및 설계 범위  
1. 연성 실시간 시스템으로 가정한다. 이는 가능한 빨리 전달되어야 하지만 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방하다.    
2. 푸시 알림, SMS 메시지, 이메일을 지원한다. 
3. iOS, 안드로이드, 랩톱 / 데스크탑을 지원한다.  
4. 클라이언트 애플리케이션 프로그램이 푸시를 만들 수도, 서버 측에서 스케줄링 할 수도 있다.  
5. 사용자의 알림 설정에 따라 보낸다.  
6. 하루에 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 5백만 건의 이메일을 보낼 수 있다.  

### 2단계 개략적 설계안 제시 및 동의 구하기   

**알림 유형별 지원 방안**  
1. iOS 푸시 알림  
: 세가지 컴포넌트가 필요하다.  
: 알림 제공자 - 알림 요청을 만들어 애플 푸시 알림 서비스를 보내는 주체다. 알림 요청을 만드려면 데이터가 필요하다,  
    -> 단말 토큰: 알림 요청을 보내는 데 필요한 고유 식별자다.  
    -> 페이로드: 알림 내용을 담은 JSON 딕셔너리이다.  
    ``` 
        {
            "aps": {
                "alert" : {
                    "title": "Game Request",
                    "body": "Bob wants to play chess",
                    "action-loc-key": "PLAY"
                },
            "badge": 5
            }
        }
    ```
: APNS - 애플이 제공하는 원격 서비스이다. 푸시 알림을 iOS 장치로 보내는 역할을 담당한다.   
: iOS 단말 - 푸시 알림을 수신하는 사용자 단말이다.  

2. 안드로이드 푸시 알림  
: 안드로이드도 비슷한 절차로 전송되며 APNS 대신 FCM을 사용한다.  

3. SMS 메시지
: 메시지를 보낼 때 보통 트윌리오, 넥스모 같은 제3 사업자의 서비스를 많이 이용한다. 

4. 이메일  
: 회사는 고유 이메일 서버를 구축할 역량은 갖추고 있다.  
: 유명한 상용 이메일 서비스로는 센드그리드, 메일침프가 있다.  


**연락처 정보 수집 절차**    
알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 계속 필요하다.  
사용자가 앱을 설치하거나 처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.   

이메일 주소와 번호는 user 테이블에 저장하고, 단말 토큰은 device 테이블에 저장한다.  
한 사용자가 여러 단말을 가질 수 있고 알림은 모든 단말에 전송되어야 한다.  


**알림 전송 및 수신 절차**  
개략적인 초안을 만들어보자.  
1. 1부터 N까지의 서비스: 마이크로서비스일 수 있고, 크론잡일 수 있고, 분산 시스템 컴포넌트일 수 있다.  
2. 알림 시스템: 전송.수신 처리의 핵심이다. 전송을 위한 API를 제공해야 하고, 제 3자 서비스에 전달할 알림 페이로드를 만들어 낼 수 있다.  
3. 제3자 서비스: 사용자에게 알림을 실제로 전달하는 역할을 한다. 유의할 점은 확장성이다. 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다. 
4. 단말: 사용자는 자기 단말에서 알림을 수신한다.  

이 설계의 문제점은 뭐가 있을까..?!

1. SPOF: 알림 서비스에 서버가 하나밖에 없다면 서버에 장애가 생기면 전체 서비스에 장애가 생긴다.  
2. 규모 확장성: 한 대의 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.  
3. 서비스 병목: 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다.   
=> 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.  

그렇다면 개선 방안을 적용해보자.  
1. 데이터베이스와 캐시를 알림 시스템의 주 서버에 분리한다.  
2. 알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록한다.  
3. 메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.  

알림 서버의 기능
: 알림 전송 API - 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다. 
: 알림 검증 - 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행한다.  
: 데이터베이스 또는 캐시 질의 - 알림에 포함된 데이터를 가져오는 기능이다.  
: 알림 전송 - 알림 데이터를 메시지 큐에 넣는다. 하나 이상의 메시지 큐를 사용해서 알림을 병렬적으로 처리할 수 있다.  

`POST https://api.exmaple.com/v/sms/sned`  
전송할 다음 사례 
```json
    {
    "to": [
      {"user_id":  12345}
    ],
    "from": {
      "email": "from_address@example.com"
    },
    "subject": "Hello, world!",
    "content": [
      {
        "type": "text/plain",
        "value": "hello world"
      }
    ]  
}
```  

캐시 - 사용자 정보, 단말 정보, 알림 템플릿 등을 캐시한다.  
데이터베이스 - 사용자, 알림, 설정 등 다양한 정보를 저장한다.   
메시지 큐 - 컴포넌트 간 의존성을 제거하기 위해 사용한다. 다량의 알림이 전송해야 하는 경우를 대비한 버퍼 역할도 한다.   
작업 서버 - 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달하는 역할을 담당하는 서버다.    
제3자 서비스  
단말  

1. API를 호출하여 알림 서버로 알림을 보낸다. 
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.  
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.  
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.  
5. 작업 서버는 알림을 제3자 서비스로 보낸다.  
6. 제3자 서비스는 사용자 단말로 알림을 전송한다.  

### 3단계 상세설계    

1. 안정성  
분산 환경에서 운영도리 알림 시스템을 설계할 때에는 안정성을 확보하기 위한몇가지 사항을 고려해야 한다.  
**데이터 손실 방지**  
알림 전송 시스템의 가장 중요한 요구사항 중 하나는 알림이 소실되면 안된다는 점이다. 이를 위해 알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 매커니즘을 구현해야 한다. 알림 로그 데이터베이스를 유지하는 것이 한 가지 방법이다.  
**알림 중복 전송 방지**  
같은 알림이 여러번 반복되는 것을 완전히 막는 것은 가능하지 않다. 대부분의 경우 알림은 한 번만 전송되지만 분산 시스템의 특성상 가끔은 같은 알림이 중복되어 전송되기도 한다. 빈도를 줄이려면 중복을 탐지하는 매커니즘을 도입하고 오류를 신중하게 처리해야 한다.  
**추가로 필요한 컴포넌트 및 고려사항**  
알림 템플릿 - 인자, 스타일, 추적 링크를 조정하기만 하면 사전에 지정된 형식에 맞춰 알림을 만들어 내는 틀이다.  
알림 설정 - 알림을 받을 것인지 테이블에 보관하여 사용자가 해당 알림을 켜두었는지 확인해야 한다.  
전송률 제한 - 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다.  
재시도 방법 - 제3자 서비스가 알림 전송에 실패하면 해당 알림을 재시도 전용 큐에 넣는다.  
푸시 알림과 보관 - 인증된 승인된 클라이언트만 해당 API를 사용하여 알림을 보낼 수 있다.  
큐 모니터링 - 큐에 쌓인 알림의 개수가 중요하다. 
이벤트 추적

### 4단계 마무리  

알림은 중요 정보를 계속 알려준다는 점에서 필요불가결한 기능이다.  
시스템 컴포넌트 사이의 결합도를 낮추기 위해 메시지 큐를 적극적으로사용하였다.  

1. 안정성: 메시지 전송 실패율을 낮취기 위해 안정적인 재시도 매커니즘을 도입하였다.  
2. 보안: 인증된 클라이언트만이 알림을 보낼 수 있도록 appKey, appSecret 등의 매커니즘을 이용하였다.  
3. 이벤트 추적 및 모니터링: 알림이 만들어진 후 성공적으로 전송되기까지의 과정을 추적하고 시스템 상태를 모니터링하기 위해 알림 전송의 각 단계마다 이벤트를 추적하고 모니터링할 수 있는 시스템을 통합하였다.  
4. 사용자 설정: 사용자가 알림 수신 설정을 조정할 수 있도록 하였다. 
5. 전송률 제한: 사용자에게 알림을 보내는 빈도를 제한할 수 있도록 하였다.  