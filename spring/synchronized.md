## Synchronized  

동기화라는 말은 정말 많이 들었는데 이렇게 사용할 줄이야! 

### 왜 이걸 알게 되었나  
1. `.jsp` 파일에서 ajax를 이용한 서버 통신을 하는 도중 더블클릭으로 인해 여러 개의 쿠폰이 발급되는 것을 확인하였다. (기본 원칙은 1인 1개 쿠폰 제공)    
2. `.jsp`에서 막으면 된다는 생각으로 전역 변수를 두어 중복을 처리했다.
3. 시니어님한테 여쭈어보았는데 `synchronized`를 추천받았다.
4. 해당 Controller 앞에 붙여 적용하니 잘 된다! 오예 ! !

<br/>

### 다시 곰곰히 생각해보자면 ... 
내가 짠 함수의 로직은 어땠을까..
```java
    @PostMapping("exchangeCoupon")
    public ... exchangeCoupon(...){
        1. 현재 로그인을 한 상태인지
        
        2. 이미 쿠폰을 발급받은 상황인지
        
        3. 현재 쿠폰 값이 맞는 쿠폰 값인지 
        
        4. 우리의 쿠폰이 맞다면 사용자에게 쿠폰 발급
        
        5. 입력한 쿠폰은 사용처리 
        }
```
이렇게 쎴을 때에 어떤 일이 일어날까?   

여러 번 클릭을 통해 하나의 바코드로 3개의 쿠폰이 생성되었다.
확인해보니 하나의 컨트롤러에서 3번의 생성이 있었으며 모두 동기화가 되지 않아 일어난 일이었다. 

<br/>

```markdown
    * 타임라인
    첫번째 클릭 발생
        이미 쿠폰을 발급받은 상황인지 처리 - X
    두번째 클릭 발생
        이미 쿠폰을 발급받은 상황인지 처리 - X
    세번째 클릭 발생
        이미 쿠폰을 발급받은 상황인지 처리 - X
        우리의 쿠폰이 맞다면 사용자에게 쿠폰 발급
        쿠폰 사용 처리
```
예시로 든 타임라인과 같이 모든 클릭을 통해 함수가 실행되어 일어난 일이었다.
그렇기에 `synchronized`를 통해 하나의 스레드가 해당 메소드에 접근할 때 `lock`을 가지고 들어가는 것이다.   
이를 통해 `exchangeCoupon` 함수는 `thread safe`한 상태가 된다.  

<br/>

### 그러면 왜 전역변수보다 synchronized가 좋을까?  
일단 이것은 나만의 생각이지만 전역변수로 두는 것은 앞으로 있을 예외 사항에 좋지 않은 것 같다.   
만약 다른 뷰에서도 `exchangeCoupon`함수를 적용한다면 계속해서 전역변수로 두어야 할 것이고 그 방법이 바람직하다고 생각하지 않는다.  
그리고 우리회사의 경우 어플과 웹 둘 다 보여주는데 웹에서만 전역변수로 막아버리면 온라인에서의 중복처리는 추가로 진행해야 할 것 같다.  
물론 프론트단에서 이미 막아도 좋지만 혹시 모르니 서버단에서도 한 번 더 처리해주는 것이 좋겠다고 생각했다.

<br/>

### 결론적인 나의 코드
```java
    @PostMapping("exchangeCoupon")
    public synchronized ... exchangeCoupon(){
    }
```
이처럼 수정하면 된다.
