## 직렬화, 역직렬화란?
1. 직렬화: 메모리를 디스크에 저장하거나 네트워크 통신에 사용하기 위한 형식으로 변환하는 것 - 자바 객체 > JSON  
2. 역직렬화: 디스크에 저장한 데이터를 읽거나, 네트워크 통신으로 받은 데이터를 메모리에 쓸 수 있도록 변환하는 것 - JSON > 자바 객체  

HTTP 응답은 서버 > 클라이언트이기에 자바 > JSON인 직렬화의 과정이고, HTTP 요청은 클라이언트 > 서버이기에 JSON > 자바 객체의 변환인 역직렬화 과정이다.  

### HTTP 요청 과정  
1. HTTP API 요청
2. 요청에 맞는 `HttpMessageConverter` 사용  
3. `HttpMessageConverter`에서 `ObjectMapper`를 사용하여 역직렬화한 결과를 반환한다.    

### HTTP 응답 과정
1. 보낼 응답에 맞는 `HttpMessageConverter` 사용  
2. `HttpMessageConverter`에서 `ObjectMapper`를 사용하여 직렬화한 결과를 반환  


### Serializable이란?  
자바에서 객체의 직렬화를 지원하기 위한 인터페이스이다.  
이를 구현한 클래스는 자바의 직렬화 기능을 활용할 수 있게 된다.  

### 1. Serializable을 사용하는 경우   
1. 엔티티의 연관 관계  
- entity 클래스는 데이터베이스의 테이블과 매핑되는 클래스로, 연관 관계나 데이터베이스에서의 특정 상태를 나타내는데 사용된다.  
- 연관 관계에 의해 다른 엔티티들과 연결되어 있을 수 있다.  

2. 분산 시스템에서의 사용  
- 분산 시스템이나 마이크로서비스 아키텍처에서도 엔티티 클래스를 직렬화하여 전달하는 경우가 있다.

3. 잠재적인 사용 시나리오 변화
- 현재는 dto를 통해 전달하더라도 나중에 시스템의 확장이나 다른 용도로 entity 클래스를 직접 전달하는 경우가 발생할 수 있다.  
  

### 2. Serializable을 사용하지 않았을 때 발생할 수 있는 문제점  
1. 버전 불일치  
- 객체를 직렬화할 때 클래스의 버전 정보(`serialVersionUID`)가 포함된다. 역직렬화 과정에서는 클래스 버전이 서로 일치해야 한다.  
- 클래스의 내용이 변경되거나 버전이 다른 경우 `InvalidClassException` 에러가 발생하여 역직렬화에 실패할 수 있다.

2. 환경의 차이  
- 객체를 직렬화한 과정과 역직렬화하는 환경이 다를 경우 문제가 발생할 수 있다.  
- 서로 다른 jdk 버전을 사용하는 경우, 클래스 패스에 클래스가 존재하지 않는 경우 등에 역직렬화 과정에서 예외가 발생할 수 있다.  

3. 직렬화 포함 여부  
- 직렬화를 구현하지않은 클래스의 객체를 직렬화하려고 할 때는 역직렬화 과정에서 `NotSerializableException` 예외가 발생한다.


### 3. Serializable을 사용하지 않아도 되는 이유   
1. dto, vo의 사용  
- 요즘 구현할 때 dto, vo를 사용하고, entity 자체를 보내는 경우는 거의 없다.  

2. 직렬화 대안 기술
- spring boot와 msa 환경에서 json, xml 등의 직렬화 대안 기술을 활용하여 데이터를 주고받는 것이 일반적이다. 
- json을 이용하는 경우 `Jackson` 라이브러리가 자동으로 객체를 json으로 변환하고 직렬화한다. 이 경우 클래스 버전과 환경의 일치성을 걱정할 필요가 없을 수 있다.  

3. 클래스 로딩 및 Classpath 관리 
- spring boot msa 환경은 클래스 로딩과 Classpath 관리를 편리하게 제공한다.  
- 필요한 클래스들을 각 마이크로서비스의 패키지 구조에 잘 배치하고, 의존성을 관리해주면 클래스 버전 및 환경의 불일치 문제를 최소화할 수 있다.    

4. 마이크로서비스 아키텍처의 장점  
- msa 환경에서는 각 서비스가 독립적으로 배포되고 실행되므로, 클래스나 환경의 변경이 각 서비스에 미치는 영향이 제한적일 수 있다.  
- 이로 인해 클래스나 환경의 변화로 인한 문제가 다른 서비스로 전파되는 것을 최소화할 수 있다.  